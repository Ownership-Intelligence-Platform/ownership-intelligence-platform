<!doctype html>
<html lang="en" class="h-full">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ownership Intelligence — Demo</title>
  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind on-the-fly config (optional): enable class-based dark mode
    tailwind.config = { darkMode: 'class' };
  </script>
  <!-- D3 -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900 dark:bg-gray-900 dark:text-gray-100 font-sans">
  <!-- Top Bar -->
  <header class="sticky top-0 z-30 bg-white/80 dark:bg-gray-900/80 backdrop-blur border-b border-gray-200 dark:border-gray-800">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex items-center justify-between h-14">
        <div class="flex items-center gap-3">
          <div class="h-8 w-8 rounded bg-indigo-600"></div>
          <h1 class="text-lg sm:text-xl font-semibold tracking-tight">Ownership Intelligence — Demo</h1>
        </div>
        <div class="flex items-center gap-2">
          <button id="populate" class="inline-flex items-center gap-2 rounded-md bg-indigo-600 px-3 py-2 text-sm font-medium text-white shadow hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500">
            Populate DB
          </button>
          <button id="clearDb" class="inline-flex items-center gap-2 rounded-md bg-rose-600 px-3 py-2 text-sm font-medium text-white shadow hover:bg-rose-500 focus:outline-none focus:ring-2 focus:ring-rose-500">
            Clear Imported Data
          </button>
          <button id="themeToggle" class="inline-flex items-center gap-2 rounded-md border border-gray-300 dark:border-gray-700 px-3 py-2 text-sm font-medium hover:bg-gray-50 dark:hover:bg-gray-800">
            <span class="hidden sm:inline">Toggle</span> Theme
          </button>
        </div>
      </div>
    </div>
  </header>

  <!-- Status bar -->
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-3">
    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-300">
      <span id="status" class="inline-block rounded bg-gray-100 dark:bg-gray-800 px-2 py-1 align-middle"></span>
    </div>
  </div>

  <!-- Main Content -->
  <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
    <!-- Controls Card -->
    <section class="mb-6">
      <div class="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-900 shadow-sm">
        <div class="px-4 py-3 border-b border-gray-200 dark:border-gray-800 flex items-center justify-between">
          <h2 class="text-base sm:text-lg font-semibold">Ownership Layers (from backend)</h2>
        </div>
        <div class="p-4">
          <div class="flex flex-wrap items-end gap-3">
            <label class="block">
              <span class="block text-xs uppercase tracking-wide text-gray-600 dark:text-gray-300">Root Entity ID</span>
              <input id="rootId" value="E1" class="mt-1 w-28 rounded-md border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500" />
            </label>
            <label class="block">
              <span class="block text-xs uppercase tracking-wide text-gray-600 dark:text-gray-300">Depth</span>
              <input id="depth" type="number" value="2" min="0" max="10" class="mt-1 w-20 rounded-md border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500" />
            </label>
            <button id="loadLayers" class="inline-flex items-center rounded-md bg-indigo-600 px-3 py-2 text-sm font-medium text-white shadow hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500">Load Layers</button>

            <label class="block ml-0 sm:ml-3">
              <span class="block text-xs uppercase tracking-wide text-gray-600 dark:text-gray-300">News Limit</span>
              <input id="newsLimit" type="number" value="5" min="1" max="50" class="mt-1 w-20 rounded-md border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-900 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500" />
            </label>
            <button id="loadNews" class="inline-flex items-center rounded-md bg-slate-700 px-3 py-2 text-sm font-medium text-white shadow hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-slate-500">Load News</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Dashboard Grid -->
    <section class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- Layers Tree Card -->
      <div class="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-900 shadow-sm">
        <div class="px-4 py-3 border-b border-gray-200 dark:border-gray-800">
          <h3 class="text-base font-semibold">Ownership Layers</h3>
        </div>
        <div id="layersTree" class="p-4 text-sm text-gray-700 dark:text-gray-200">Enter a root entity and click "Load Layers".</div>
      </div>

      <!-- Representatives Card -->
      <div class="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-900 shadow-sm">
        <div class="px-4 py-3 border-b border-gray-200 dark:border-gray-800">
          <h3 class="text-base font-semibold">Legal Representatives</h3>
        </div>
        <div id="repsList" class="p-4 text-sm text-gray-500 dark:text-gray-400">Load a company to see its legal representatives.</div>
      </div>

      <!-- News Card -->
      <div class="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-900 shadow-sm lg:col-span-2">
        <div class="px-4 py-3 border-b border-gray-200 dark:border-gray-800">
          <h3 class="text-base font-semibold">Company News</h3>
        </div>
        <div id="newsList" class="p-4 text-sm text-gray-500 dark:text-gray-400">Load a company to see recent news (stored + external).</div>
      </div>

      <!-- Penetration Card -->
      <div class="rounded-lg border border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-900 shadow-sm lg:col-span-2">
        <div class="px-4 py-3 border-b border-gray-200 dark:border-gray-800 flex items-center justify-between">
          <h3 class="text-base font-semibold">Equity Penetration (D3)</h3>
          <button id="loadPenetration" class="inline-flex items-center rounded-md bg-emerald-600 px-3 py-2 text-sm font-medium text-white shadow hover:bg-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500">Load Equity Penetration Graph</button>
        </div>
        <div class="p-4">
          <div id="penetrationChart" class="w-full overflow-hidden rounded border border-gray-200 dark:border-gray-800 bg-gray-50 dark:bg-gray-800"></div>
          <div id="legend" class="mt-2 text-xs text-gray-600 dark:text-gray-300">
            <strong>Legend:</strong> Node size/color = Equity Penetration (look-through %). Link width = stake %. Label shows stake and look-through via that edge.
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Theme toggle: toggles the 'dark' class on the root element
    (function() {
      const root = document.documentElement;
      const key = 'oi_theme';
      function applyTheme(val){
        if (val === 'dark') root.classList.add('dark'); else root.classList.remove('dark');
      }
      try {
        applyTheme(localStorage.getItem(key));
      } catch {}
      const btn = document.getElementById('themeToggle');
      if (btn) btn.addEventListener('click', () => {
        const next = root.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(next);
        try { localStorage.setItem(key, next); } catch {}
      });
    })();
  </script>

  <script>
  function text(str) { return document.createTextNode(str); }

    function renderTree(container, tree, rootId) {
      container.innerHTML = '';
      if (!tree) { container.textContent = 'No data'; return; }

      function nodeLabel(n) {
        const name = n.name || '(no name)';
        return `${name} [${n.id}]${n.type ? ' · ' + n.type : ''}`;
      }

      function buildList(node, parentId) {
        const li = document.createElement('li');
        const label = nodeLabel(node);
        li.appendChild(text(label));
        if (parentId && node._stakeFromParent != null) {
          const stakeEl = document.createElement('span');
          stakeEl.style.marginLeft = '6px';
          stakeEl.style.color = '#555';
          stakeEl.textContent = `(stake: ${Number(node._stakeFromParent).toFixed(2)}%)`;
          li.appendChild(stakeEl);
        }
        if (node.children && node.children.length) {
          const ul = document.createElement('ul');
          node.children.forEach(child => ul.appendChild(buildList(child, node.id)));
          li.appendChild(ul);
        }
        return li;
      }

      const rootList = document.createElement('ul');
      rootList.appendChild(buildList(tree, null));
      container.appendChild(rootList);
    }

    function buildTreeFromPaths(payload) {
      // payload: { root: {id,name,type}, layers: [{nodes:[...], rels:[{from,to,stake}]} ...] }
      if (!payload || !payload.root) return null;
      const nodesById = new Map();
      const ensureNode = (n) => {
        if (!nodesById.has(n.id)) nodesById.set(n.id, { id: n.id, name: n.name, type: n.type, children: [] });
        const existing = nodesById.get(n.id);
        // keep latest known name/type if available
        if (n.name) existing.name = n.name;
        if (n.type) existing.type = n.type;
        return existing;
      };

      // Ensure root exists
      const rootNode = ensureNode(payload.root);

      // Merge all paths into a single tree
      (payload.layers || []).forEach(path => {
        const { nodes = [], rels = [] } = path || {};
        // Ensure nodes exist in map
        nodes.forEach(ensureNode);
        // Link by rels order
        rels.forEach(rel => {
          const parent = nodesById.get(rel.from);
          const child = nodesById.get(rel.to);
          if (!parent || !child) return;
          // Avoid duplicate child edges
          const has = parent.children.some(c => c.id === child.id);
          if (!has) {
            const childRef = nodesById.get(child.id);
            // annotate stake from parent for label
            const annotated = { ...childRef, _stakeFromParent: rel.stake };
            // note: we keep reference semantics shallow; rendering uses fields
            parent.children.push(annotated);
          }
        });
      });

      return nodesById.get(payload.root.id) || rootNode;
    }

    async function loadLayers() {
      const rootId = document.getElementById('rootId').value.trim();
      const depth = Number(document.getElementById('depth').value || 2);
      if (!rootId) { alert('Please enter a root entity id'); return; }

      const treeEl = document.getElementById('layersTree');
      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Loading layers…';
      try {
        const res = await fetch(`/layers/${encodeURIComponent(rootId)}?depth=${depth}`);
        if (!res.ok) {
          const errText = await res.text();
          treeEl.textContent = `Failed to load layers (${res.status}): ${errText}`;
          statusEl.textContent = '';
          return;
        }
        const data = await res.json();
        const tree = buildTreeFromPaths(data);
        if (!tree) {
          treeEl.textContent = 'No layers found for this root.';
        } else {
          renderTree(treeEl, tree, data?.root?.id);
        }
        // Also load legal representatives and news for this company id
        await Promise.all([
          loadRepresentatives(rootId),
          loadNews(rootId)
        ]);
      } catch (e) {
        treeEl.textContent = `Error: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 1500);
      }
    }
    async function loadRepresentatives(companyId) {
      const el = document.getElementById('repsList');
      el.textContent = 'Loading representatives…';
      try {
        const res = await fetch(`/representatives/${encodeURIComponent(companyId)}`);
        if (!res.ok) {
          el.textContent = 'No representatives found.';
          return;
        }
        const data = await res.json();
        const reps = (data && data.representatives) || [];
        if (!reps.length) {
          el.textContent = 'No representatives found.';
          return;
        }
        const ul = document.createElement('ul');
        reps.forEach(r => {
          const li = document.createElement('li');
          const label = `${r.name || '(no name)'} [${r.id}]${r.type ? ' · ' + r.type : ''}${r.role ? ' — ' + r.role : ''}`;
          li.textContent = label;
          ul.appendChild(li);
        });
        el.innerHTML = '';
        el.appendChild(ul);
      } catch (e) {
        el.textContent = `Error loading representatives: ${e}`;
      }
    }

    async function loadNews(entityId) {
      const el = document.getElementById('newsList');
      const limit = Number(document.getElementById('newsLimit').value || 5);
      el.textContent = 'Loading news…';
      try {
        const res = await fetch(`/entities/${encodeURIComponent(entityId)}/news?limit=${limit}`);
        if (!res.ok) {
          const txt = await res.text();
          el.textContent = `Failed to load news: ${res.status} ${txt}`;
          return;
        }
        const data = await res.json();
        const items = (data && data.items) || [];
        if (!items.length) {
          el.textContent = 'No recent news found.';
          return;
        }
        // Show counts breakdown
        const metaLine = document.createElement('div');
        metaLine.className = 'muted';
        metaLine.style.marginBottom = '4px';
        metaLine.textContent = `Showing ${items.length} (stored: ${data.stored_count || 0}, external: ${data.external_count || 0})`;
        const frag = document.createDocumentFragment();
        frag.appendChild(metaLine);
        const ul = document.createElement('ul');
        items.forEach(n => {
          const li = document.createElement('li');
          const a = document.createElement('a');
          a.href = n.url || '#';
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.textContent = n.title || '(untitled)';
          li.appendChild(a);
          const meta = [];
          if (n.source) meta.push(n.source);
          if (n.published_at) meta.push(String(n.published_at).slice(0, 19));
          if (meta.length) {
            const span = document.createElement('span');
            span.className = 'muted';
            span.style.marginLeft = '6px';
            span.textContent = `— ${meta.join(' · ')}`;
            li.appendChild(span);
          }
          if (n.summary) {
            const d = document.createElement('div');
            d.className = 'muted';
            d.style.marginTop = '2px';
            d.textContent = n.summary;
            li.appendChild(d);
          }
          if (n.stored) {
            const badge = document.createElement('span');
            badge.textContent = ' stored';
            badge.style.background = '#ffd54f';
            badge.style.color = '#553';
            badge.style.fontSize = '0.7rem';
            badge.style.padding = '2px 4px';
            badge.style.borderRadius = '4px';
            badge.style.marginLeft = '6px';
            li.appendChild(badge);
          }
          ul.appendChild(li);
        });
        frag.appendChild(ul);
        el.innerHTML = '';
        el.appendChild(frag);
      } catch (e) {
        el.textContent = `Error loading news: ${e}`;
      }
    }

    

    async function populateMock() {
      document.getElementById('status').textContent = 'Populating...';
      const res = await fetch('/populate-mock', { method: 'POST' });
      const txt = await res.json().catch(()=>({message: res.statusText}));
      document.getElementById('status').textContent = JSON.stringify(txt);
      // After populating, try loading default root E1 automatically
      try {
        await loadLayers();
      } catch {}
      setTimeout(()=>document.getElementById('status').textContent='', 3000);
    }

    async function clearDb() {
      if (!confirm('This will delete ALL nodes and relationships in Neo4j. Continue?')) return;
      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Clearing database…';
      try {
        const res = await fetch('/clear-db', { method: 'POST' });
        const data = await res.json().catch(()=>({ message: res.statusText }));
        statusEl.textContent = typeof data === 'object' ? JSON.stringify(data) : String(data);
        // Clear UI sections
        document.getElementById('layersTree').textContent = 'Database cleared. Re-populate to view layers.';
        document.getElementById('penetrationChart').textContent = '';
      } catch (e) {
        statusEl.textContent = `Failed to clear: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 3000);
      }
    }

    async function loadPenetration() {
      const rootId = document.getElementById('rootId').value.trim();
      const depth = Number(document.getElementById('depth').value || 3);
      if (!rootId) { alert('Please enter a root entity id'); return; }

      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Loading penetration…';
      try {
        // Fetch both the penetration values and the graph layers to build a network
        const [penRes, layersRes] = await Promise.all([
          fetch(`/penetration/${encodeURIComponent(rootId)}?depth=${depth}`),
          fetch(`/layers/${encodeURIComponent(rootId)}?depth=${depth}`)
        ]);
        if (!penRes.ok) {
          const txt = await penRes.text();
          document.getElementById('penetrationChart').textContent = `Failed to load penetration: ${penRes.status} ${txt}`;
          statusEl.textContent = '';
          return;
        }
        if (!layersRes.ok) {
          const txt = await layersRes.text();
          document.getElementById('penetrationChart').textContent = `Failed to load layers: ${layersRes.status} ${txt}`;
          statusEl.textContent = '';
          return;
        }
        const penData = await penRes.json();
        const layersData = await layersRes.json();
        const graph = buildGraphFromLayersAndPenetration(layersData, penData);
        renderPenetrationGraph(graph, penData?.root);
      } catch (e) {
        document.getElementById('penetrationChart').textContent = `Error: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 1500);
      }
    }

    function buildGraphFromLayersAndPenetration(layersPayload, penetrationPayload) {
      // Build nodes and links from layers; annotate nodes with penetration values
      const nodesById = new Map();
      const penetrationById = new Map();
      const links = [];

      // Map penetration values
      (penetrationPayload?.items || []).forEach(item => {
        if (item?.id != null) penetrationById.set(item.id, item.penetration || 0);
      });

      const ensureNode = (n) => {
        if (!n || !n.id) return null;
        if (!nodesById.has(n.id)) {
          nodesById.set(n.id, { id: n.id, name: n.name, type: n.type, penetration: penetrationById.get(n.id) || 0 });
        } else {
          const ref = nodesById.get(n.id);
          if (n.name) ref.name = n.name;
          if (n.type) ref.type = n.type;
          // keep penetration if already set
        }
        return nodesById.get(n.id);
      };

      let rootId = null;
      if (layersPayload?.root) {
        const r = ensureNode(layersPayload.root);
        rootId = layersPayload.root.id;
        // Set root penetration to 100 for visualization context
        if (r && (r.penetration == null || r.penetration === 0)) r.penetration = 100;
      }

      (layersPayload?.layers || []).forEach(path => {
        const nodes = path?.nodes || [];
        const rels = path?.rels || [];
        nodes.forEach(ensureNode);
        rels.forEach(rel => {
          if (!rel) return;
          const s = nodesById.get(rel.from);
          const t = nodesById.get(rel.to);
          if (!s || !t) return;
          // Avoid duplicate link entries
          const key = `${rel.from}->${rel.to}`;
          if (!links.find(l => l._k === key)) {
            const parentPen = (rel.from === rootId ? 100 : (penetrationById.get(rel.from) || 0));
            const lt = parentPen * (Number(rel.stake) || 0) / 100;
            links.push({ source: rel.from, target: rel.to, stake: rel.stake, lookthrough: lt, _k: key });
          }
        });
      });

      return { nodes: Array.from(nodesById.values()), links };
    }

    function renderPenetrationGraph(graph, root) {
      const chartEl = document.getElementById('penetrationChart');
      chartEl.innerHTML = '';
      if (!graph || !graph.nodes || !graph.nodes.length) {
        chartEl.textContent = 'No graph data available.';
        return;
      }

      // Dimensions
      const width = 900;
      const height = 520;

      // Scales
      const maxPen = d3.max(graph.nodes, d => d.penetration || 0) || 100;
      const radius = d3.scaleSqrt().domain([0, maxPen]).range([6, 30]);
      const color = d3.scaleSequential(d3.interpolateBlues).domain([0, maxPen || 1]);
      const linkWidth = d3.scaleLinear().domain([0, 100]).range([0.5, 6]);

      const svg = d3.select(chartEl).append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('border', '1px solid #eee')
        .style('background', '#fafafa');

      if (root) {
        d3.select(chartEl)
          .insert('div', ':first-child')
          .style('margin', '6px 0')
          .style('color', '#555')
          .text(`Root: ${root.name || ''} [${root.id}]${root.type ? ' · ' + root.type : ''}`);
      }

      const g = svg.append('g');

      // Zoom & pan
      const zoom = d3.zoom().scaleExtent([0.2, 4]).on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
      svg.call(zoom);

      // Define arrowheads
      const defs = svg.append('defs');
      defs.append('marker')
        .attr('id', 'arrow')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 14)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

      const link = g.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
        .selectAll('line')
        .data(graph.links)
        .enter()
        .append('line')
        .attr('stroke-width', d => linkWidth(d.stake || 0))
        .attr('marker-end', 'url(#arrow)');

      // Link labels (stake %)
      const linkLabels = g.append('g')
        .selectAll('text')
        .data(graph.links)
        .enter()
        .append('text')
        .attr('font-size', 10)
        .attr('fill', '#555')
        .text(d => {
          const stakeTxt = d.stake != null ? `${Number(d.stake).toFixed(1)}%` : '';
          const ltTxt = d.lookthrough != null && !isNaN(d.lookthrough) ? ` (LT ${(Number(d.lookthrough)).toFixed(1)}%)` : '';
          return stakeTxt + ltTxt;
        });

      const node = g.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .selectAll('g.node')
        .data(graph.nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      node.append('circle')
        .attr('r', d => radius(d.penetration || 0))
        .attr('fill', d => color(d.penetration || 0));

      node.append('title')
        .text(d => `${d.name || '(no name)'}\n[${d.id}]${d.type ? ' · ' + d.type : ''}\nPenetration: ${(d.penetration || 0).toFixed(2)}%`);

      node.append('text')
        .attr('x', 12)
        .attr('y', 4)
        .attr('font-size', 11)
        .attr('fill', '#333')
        .text(d => {
          const base = d.name || '(no name)';
          return `${base} (${(d.penetration || 0).toFixed(1)}%)`;
        });

      const sim = d3.forceSimulation(graph.nodes)
        .force('link', d3.forceLink(graph.links).id(d => d.id).distance(90).strength(0.2))
        .force('charge', d3.forceManyBody().strength(-200))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide().radius(d => radius(d.penetration || 0) + 10));

      sim.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node.attr('transform', d => `translate(${d.x},${d.y})`);

        linkLabels
          .attr('x', d => (d.source.x + d.target.x) / 2)
          .attr('y', d => (d.source.y + d.target.y) / 2);
      });

      function dragstarted(event, d) {
        if (!event.active) sim.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event, d) {
        if (!event.active) sim.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }

    document.getElementById('populate').addEventListener('click', populateMock);
    document.getElementById('clearDb').addEventListener('click', clearDb);
    document.getElementById('loadLayers').addEventListener('click', loadLayers);
    document.getElementById('loadPenetration').addEventListener('click', loadPenetration);
    document.getElementById('loadNews').addEventListener('click', () => {
      const id = document.getElementById('rootId').value.trim();
      if (!id) { alert('Please enter an entity id'); return; }
      loadNews(id);
    });
    // Auto-load default tree if DB already has data
    // loadLayers();
  </script>
</body>
</html>
