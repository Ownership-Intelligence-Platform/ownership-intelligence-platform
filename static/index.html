<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ownership Intelligence — Demo</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; padding: 20px; max-width: 900px; }
    pre { background:#f4f4f4; padding:10px; border-radius:6px; white-space:pre-wrap; }
    button { margin-right:8px; }
    .muted { color:#666; font-size:0.9rem }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>
<body>
  <h1>Ownership Intelligence — Demo</h1>
  <p class="muted">A tiny static UI that shows client-side mock data and can populate the Neo4j DB with sample data.</p>

  <div>
    <button id="populate">Populate DB with Mock Data</button>
    <button id="clearDb" style="color:#a00">Clear Imported Data (DB)</button>
    <span id="status"></span>
  </div>

  <h2>Ownership Layers (from backend)</h2>
  <div style="margin-bottom:10px">
    <label>
      Root Entity ID:
      <input id="rootId" value="E1" style="width:90px" />
    </label>
    <label style="margin-left:8px">
      Depth:
      <input id="depth" type="number" value="2" min="0" max="10" style="width:60px" />
    </label>
    <button id="loadLayers">Load Layers</button>
    <label style="margin-left:12px">
      News Limit:
      <input id="newsLimit" type="number" value="5" min="1" max="50" style="width:60px" />
    </label>
    <button id="loadNews">Load News</button>
  </div>

  <div id="layersTree">Enter a root entity and click "Load Layers".</div>

  <h2>Legal Representatives</h2>
  <div id="repsList" class="muted">Load a company to see its legal representatives.</div>

  <h2>Company News</h2>
  <div id="newsList" class="muted">Load a company to see recent news.</div>

  <h2>Equity Penetration (D3)</h2>
  <div style="margin-bottom:10px">
    <button id="loadPenetration">Load Equity Penetration Graph</button>
  </div>
  <div id="penetrationChart"></div>
  <div id="legend" class="muted" style="margin-top:8px">
    <strong>Legend:</strong> Node size/color = Equity Penetration (look-through %). Link width = stake %. Label shows stake and look-through via that edge.
  </div>


  <h2>Notes</h2>
  <ul>
    <li>GET <code>/mock-data</code> — returns client-side mock dataset</li>
    <li>POST <code>/populate-mock</code> — creates sample entities/ownerships in Neo4j</li>
    <li>Other API endpoints: <code>/entities</code>, <code>/ownerships</code>, <code>/layers/{id}</code></li>
  </ul>

  <script>
    function text(str) { return document.createTextNode(str); }

    function renderTree(container, tree, rootId) {
      container.innerHTML = '';
      if (!tree) { container.textContent = 'No data'; return; }

      function nodeLabel(n) {
        const name = n.name || '(no name)';
        return `${name} [${n.id}]${n.type ? ' · ' + n.type : ''}`;
      }

      function buildList(node, parentId) {
        const li = document.createElement('li');
        const label = nodeLabel(node);
        li.appendChild(text(label));
        if (parentId && node._stakeFromParent != null) {
          const stakeEl = document.createElement('span');
          stakeEl.style.marginLeft = '6px';
          stakeEl.style.color = '#555';
          stakeEl.textContent = `(stake: ${Number(node._stakeFromParent).toFixed(2)}%)`;
          li.appendChild(stakeEl);
        }
        if (node.children && node.children.length) {
          const ul = document.createElement('ul');
          node.children.forEach(child => ul.appendChild(buildList(child, node.id)));
          li.appendChild(ul);
        }
        return li;
      }

      const rootList = document.createElement('ul');
      rootList.appendChild(buildList(tree, null));
      container.appendChild(rootList);
    }

    function buildTreeFromPaths(payload) {
      // payload: { root: {id,name,type}, layers: [{nodes:[...], rels:[{from,to,stake}]} ...] }
      if (!payload || !payload.root) return null;
      const nodesById = new Map();
      const ensureNode = (n) => {
        if (!nodesById.has(n.id)) nodesById.set(n.id, { id: n.id, name: n.name, type: n.type, children: [] });
        const existing = nodesById.get(n.id);
        // keep latest known name/type if available
        if (n.name) existing.name = n.name;
        if (n.type) existing.type = n.type;
        return existing;
      };

      // Ensure root exists
      const rootNode = ensureNode(payload.root);

      // Merge all paths into a single tree
      (payload.layers || []).forEach(path => {
        const { nodes = [], rels = [] } = path || {};
        // Ensure nodes exist in map
        nodes.forEach(ensureNode);
        // Link by rels order
        rels.forEach(rel => {
          const parent = nodesById.get(rel.from);
          const child = nodesById.get(rel.to);
          if (!parent || !child) return;
          // Avoid duplicate child edges
          const has = parent.children.some(c => c.id === child.id);
          if (!has) {
            const childRef = nodesById.get(child.id);
            // annotate stake from parent for label
            const annotated = { ...childRef, _stakeFromParent: rel.stake };
            // note: we keep reference semantics shallow; rendering uses fields
            parent.children.push(annotated);
          }
        });
      });

      return nodesById.get(payload.root.id) || rootNode;
    }

    async function loadLayers() {
      const rootId = document.getElementById('rootId').value.trim();
      const depth = Number(document.getElementById('depth').value || 2);
      if (!rootId) { alert('Please enter a root entity id'); return; }

      const treeEl = document.getElementById('layersTree');
      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Loading layers…';
      try {
        const res = await fetch(`/layers/${encodeURIComponent(rootId)}?depth=${depth}`);
        if (!res.ok) {
          const errText = await res.text();
          treeEl.textContent = `Failed to load layers (${res.status}): ${errText}`;
          statusEl.textContent = '';
          return;
        }
        const data = await res.json();
        const tree = buildTreeFromPaths(data);
        if (!tree) {
          treeEl.textContent = 'No layers found for this root.';
        } else {
          renderTree(treeEl, tree, data?.root?.id);
        }
        // Also load legal representatives and news for this company id
        await Promise.all([
          loadRepresentatives(rootId),
          loadNews(rootId)
        ]);
      } catch (e) {
        treeEl.textContent = `Error: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 1500);
      }
    }
    async function loadRepresentatives(companyId) {
      const el = document.getElementById('repsList');
      el.textContent = 'Loading representatives…';
      try {
        const res = await fetch(`/representatives/${encodeURIComponent(companyId)}`);
        if (!res.ok) {
          el.textContent = 'No representatives found.';
          return;
        }
        const data = await res.json();
        const reps = (data && data.representatives) || [];
        if (!reps.length) {
          el.textContent = 'No representatives found.';
          return;
        }
        const ul = document.createElement('ul');
        reps.forEach(r => {
          const li = document.createElement('li');
          const label = `${r.name || '(no name)'} [${r.id}]${r.type ? ' · ' + r.type : ''}${r.role ? ' — ' + r.role : ''}`;
          li.textContent = label;
          ul.appendChild(li);
        });
        el.innerHTML = '';
        el.appendChild(ul);
      } catch (e) {
        el.textContent = `Error loading representatives: ${e}`;
      }
    }

    async function loadNews(entityId) {
      const el = document.getElementById('newsList');
      const limit = Number(document.getElementById('newsLimit').value || 5);
      el.textContent = 'Loading news…';
      try {
        const res = await fetch(`/entities/${encodeURIComponent(entityId)}/news?limit=${limit}`);
        if (!res.ok) {
          const txt = await res.text();
          el.textContent = `Failed to load news: ${res.status} ${txt}`;
          return;
        }
        const data = await res.json();
        const items = (data && data.items) || [];
        if (!items.length) {
          el.textContent = 'No recent news found.';
          return;
        }
        const frag = document.createDocumentFragment();
        const ul = document.createElement('ul');
        items.forEach(n => {
          const li = document.createElement('li');
          const a = document.createElement('a');
          a.href = n.url || '#';
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.textContent = n.title || '(untitled)';
          li.appendChild(a);
          const meta = [];
          if (n.source) meta.push(n.source);
          if (n.published_at) meta.push(String(n.published_at).slice(0, 19));
          if (meta.length) {
            const span = document.createElement('span');
            span.className = 'muted';
            span.style.marginLeft = '6px';
            span.textContent = `— ${meta.join(' · ')}`;
            li.appendChild(span);
          }
          if (n.summary) {
            const d = document.createElement('div');
            d.className = 'muted';
            d.style.marginTop = '2px';
            d.textContent = n.summary;
            li.appendChild(d);
          }
          ul.appendChild(li);
        });
        frag.appendChild(ul);
        el.innerHTML = '';
        el.appendChild(frag);
      } catch (e) {
        el.textContent = `Error loading news: ${e}`;
      }
    }

    

    async function populateMock() {
      document.getElementById('status').textContent = 'Populating...';
      const res = await fetch('/populate-mock', { method: 'POST' });
      const txt = await res.json().catch(()=>({message: res.statusText}));
      document.getElementById('status').textContent = JSON.stringify(txt);
      // After populating, try loading default root E1 automatically
      try {
        await loadLayers();
      } catch {}
      setTimeout(()=>document.getElementById('status').textContent='', 3000);
    }

    async function clearDb() {
      if (!confirm('This will delete ALL nodes and relationships in Neo4j. Continue?')) return;
      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Clearing database…';
      try {
        const res = await fetch('/clear-db', { method: 'POST' });
        const data = await res.json().catch(()=>({ message: res.statusText }));
        statusEl.textContent = typeof data === 'object' ? JSON.stringify(data) : String(data);
        // Clear UI sections
        document.getElementById('layersTree').textContent = 'Database cleared. Re-populate to view layers.';
        document.getElementById('penetrationChart').textContent = '';
      } catch (e) {
        statusEl.textContent = `Failed to clear: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 3000);
      }
    }

    async function loadPenetration() {
      const rootId = document.getElementById('rootId').value.trim();
      const depth = Number(document.getElementById('depth').value || 3);
      if (!rootId) { alert('Please enter a root entity id'); return; }

      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Loading penetration…';
      try {
        // Fetch both the penetration values and the graph layers to build a network
        const [penRes, layersRes] = await Promise.all([
          fetch(`/penetration/${encodeURIComponent(rootId)}?depth=${depth}`),
          fetch(`/layers/${encodeURIComponent(rootId)}?depth=${depth}`)
        ]);
        if (!penRes.ok) {
          const txt = await penRes.text();
          document.getElementById('penetrationChart').textContent = `Failed to load penetration: ${penRes.status} ${txt}`;
          statusEl.textContent = '';
          return;
        }
        if (!layersRes.ok) {
          const txt = await layersRes.text();
          document.getElementById('penetrationChart').textContent = `Failed to load layers: ${layersRes.status} ${txt}`;
          statusEl.textContent = '';
          return;
        }
        const penData = await penRes.json();
        const layersData = await layersRes.json();
        const graph = buildGraphFromLayersAndPenetration(layersData, penData);
        renderPenetrationGraph(graph, penData?.root);
      } catch (e) {
        document.getElementById('penetrationChart').textContent = `Error: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 1500);
      }
    }

    function buildGraphFromLayersAndPenetration(layersPayload, penetrationPayload) {
      // Build nodes and links from layers; annotate nodes with penetration values
      const nodesById = new Map();
      const penetrationById = new Map();
      const links = [];

      // Map penetration values
      (penetrationPayload?.items || []).forEach(item => {
        if (item?.id != null) penetrationById.set(item.id, item.penetration || 0);
      });

      const ensureNode = (n) => {
        if (!n || !n.id) return null;
        if (!nodesById.has(n.id)) {
          nodesById.set(n.id, { id: n.id, name: n.name, type: n.type, penetration: penetrationById.get(n.id) || 0 });
        } else {
          const ref = nodesById.get(n.id);
          if (n.name) ref.name = n.name;
          if (n.type) ref.type = n.type;
          // keep penetration if already set
        }
        return nodesById.get(n.id);
      };

      let rootId = null;
      if (layersPayload?.root) {
        const r = ensureNode(layersPayload.root);
        rootId = layersPayload.root.id;
        // Set root penetration to 100 for visualization context
        if (r && (r.penetration == null || r.penetration === 0)) r.penetration = 100;
      }

      (layersPayload?.layers || []).forEach(path => {
        const nodes = path?.nodes || [];
        const rels = path?.rels || [];
        nodes.forEach(ensureNode);
        rels.forEach(rel => {
          if (!rel) return;
          const s = nodesById.get(rel.from);
          const t = nodesById.get(rel.to);
          if (!s || !t) return;
          // Avoid duplicate link entries
          const key = `${rel.from}->${rel.to}`;
          if (!links.find(l => l._k === key)) {
            const parentPen = (rel.from === rootId ? 100 : (penetrationById.get(rel.from) || 0));
            const lt = parentPen * (Number(rel.stake) || 0) / 100;
            links.push({ source: rel.from, target: rel.to, stake: rel.stake, lookthrough: lt, _k: key });
          }
        });
      });

      return { nodes: Array.from(nodesById.values()), links };
    }

    function renderPenetrationGraph(graph, root) {
      const chartEl = document.getElementById('penetrationChart');
      chartEl.innerHTML = '';
      if (!graph || !graph.nodes || !graph.nodes.length) {
        chartEl.textContent = 'No graph data available.';
        return;
      }

      // Dimensions
      const width = 900;
      const height = 520;

      // Scales
      const maxPen = d3.max(graph.nodes, d => d.penetration || 0) || 100;
      const radius = d3.scaleSqrt().domain([0, maxPen]).range([6, 30]);
      const color = d3.scaleSequential(d3.interpolateBlues).domain([0, maxPen || 1]);
      const linkWidth = d3.scaleLinear().domain([0, 100]).range([0.5, 6]);

      const svg = d3.select(chartEl).append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('border', '1px solid #eee')
        .style('background', '#fafafa');

      if (root) {
        d3.select(chartEl)
          .insert('div', ':first-child')
          .style('margin', '6px 0')
          .style('color', '#555')
          .text(`Root: ${root.name || ''} [${root.id}]${root.type ? ' · ' + root.type : ''}`);
      }

      const g = svg.append('g');

      // Zoom & pan
      const zoom = d3.zoom().scaleExtent([0.2, 4]).on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
      svg.call(zoom);

      // Define arrowheads
      const defs = svg.append('defs');
      defs.append('marker')
        .attr('id', 'arrow')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 14)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#999');

      const link = g.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
        .selectAll('line')
        .data(graph.links)
        .enter()
        .append('line')
        .attr('stroke-width', d => linkWidth(d.stake || 0))
        .attr('marker-end', 'url(#arrow)');

      // Link labels (stake %)
      const linkLabels = g.append('g')
        .selectAll('text')
        .data(graph.links)
        .enter()
        .append('text')
        .attr('font-size', 10)
        .attr('fill', '#555')
        .text(d => {
          const stakeTxt = d.stake != null ? `${Number(d.stake).toFixed(1)}%` : '';
          const ltTxt = d.lookthrough != null && !isNaN(d.lookthrough) ? ` (LT ${(Number(d.lookthrough)).toFixed(1)}%)` : '';
          return stakeTxt + ltTxt;
        });

      const node = g.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .selectAll('g.node')
        .data(graph.nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      node.append('circle')
        .attr('r', d => radius(d.penetration || 0))
        .attr('fill', d => color(d.penetration || 0));

      node.append('title')
        .text(d => `${d.name || '(no name)'}\n[${d.id}]${d.type ? ' · ' + d.type : ''}\nPenetration: ${(d.penetration || 0).toFixed(2)}%`);

      node.append('text')
        .attr('x', 12)
        .attr('y', 4)
        .attr('font-size', 11)
        .attr('fill', '#333')
        .text(d => {
          const base = d.name || '(no name)';
          return `${base} (${(d.penetration || 0).toFixed(1)}%)`;
        });

      const sim = d3.forceSimulation(graph.nodes)
        .force('link', d3.forceLink(graph.links).id(d => d.id).distance(90).strength(0.2))
        .force('charge', d3.forceManyBody().strength(-200))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collide', d3.forceCollide().radius(d => radius(d.penetration || 0) + 10));

      sim.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node.attr('transform', d => `translate(${d.x},${d.y})`);

        linkLabels
          .attr('x', d => (d.source.x + d.target.x) / 2)
          .attr('y', d => (d.source.y + d.target.y) / 2);
      });

      function dragstarted(event, d) {
        if (!event.active) sim.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event, d) {
        if (!event.active) sim.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }

    document.getElementById('populate').addEventListener('click', populateMock);
    document.getElementById('clearDb').addEventListener('click', clearDb);
    document.getElementById('loadLayers').addEventListener('click', loadLayers);
    document.getElementById('loadPenetration').addEventListener('click', loadPenetration);
    document.getElementById('loadNews').addEventListener('click', () => {
      const id = document.getElementById('rootId').value.trim();
      if (!id) { alert('Please enter an entity id'); return; }
      loadNews(id);
    });
    // Auto-load default tree if DB already has data
    // loadLayers();
  </script>
</body>
</html>
