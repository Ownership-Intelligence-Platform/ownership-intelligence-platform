<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ownership Intelligence — Demo</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; padding: 20px; max-width: 900px; }
    pre { background:#f4f4f4; padding:10px; border-radius:6px; white-space:pre-wrap; }
    button { margin-right:8px; }
    .muted { color:#666; font-size:0.9rem }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>
<body>
  <h1>Ownership Intelligence — Demo</h1>
  <p class="muted">A tiny static UI that shows client-side mock data and can populate the Neo4j DB with sample data.</p>

  <div>
    <button id="refresh">Refresh Mock Data</button>
    <button id="populate">Populate DB with Mock Data</button>
    <span id="status"></span>
  </div>

  <h2>Ownership Layers (from backend)</h2>
  <div style="margin-bottom:10px">
    <label>
      Root Entity ID:
      <input id="rootId" value="E1" style="width:90px" />
    </label>
    <label style="margin-left:8px">
      Depth:
      <input id="depth" type="number" value="2" min="0" max="10" style="width:60px" />
    </label>
    <button id="loadLayers">Load Layers</button>
  </div>

  <div id="layersTree">Enter a root entity and click "Load Layers".</div>

  <h2>Equity Penetration (D3)</h2>
  <div style="margin-bottom:10px">
    <button id="loadPenetration">Load Equity Penetration</button>
  </div>
  <div id="penetrationChart"></div>

  <h2>Mock Data (client-side)</h2>
  <pre id="mockJson">Loading...</pre>

  <h2>Notes</h2>
  <ul>
    <li>GET <code>/mock-data</code> — returns client-side mock dataset</li>
    <li>POST <code>/populate-mock</code> — creates sample entities/ownerships in Neo4j</li>
    <li>Other API endpoints: <code>/entities</code>, <code>/ownerships</code>, <code>/layers/{id}</code></li>
  </ul>

  <script>
    function text(str) { return document.createTextNode(str); }

    function renderTree(container, tree, rootId) {
      container.innerHTML = '';
      if (!tree) { container.textContent = 'No data'; return; }

      function nodeLabel(n) {
        const name = n.name || '(no name)';
        return `${name} [${n.id}]${n.type ? ' · ' + n.type : ''}`;
      }

      function buildList(node, parentId) {
        const li = document.createElement('li');
        const label = nodeLabel(node);
        li.appendChild(text(label));
        if (parentId && node._stakeFromParent != null) {
          const stakeEl = document.createElement('span');
          stakeEl.style.marginLeft = '6px';
          stakeEl.style.color = '#555';
          stakeEl.textContent = `(stake: ${Number(node._stakeFromParent).toFixed(2)}%)`;
          li.appendChild(stakeEl);
        }
        if (node.children && node.children.length) {
          const ul = document.createElement('ul');
          node.children.forEach(child => ul.appendChild(buildList(child, node.id)));
          li.appendChild(ul);
        }
        return li;
      }

      const rootList = document.createElement('ul');
      rootList.appendChild(buildList(tree, null));
      container.appendChild(rootList);
    }

    function buildTreeFromPaths(payload) {
      // payload: { root: {id,name,type}, layers: [{nodes:[...], rels:[{from,to,stake}]} ...] }
      if (!payload || !payload.root) return null;
      const nodesById = new Map();
      const ensureNode = (n) => {
        if (!nodesById.has(n.id)) nodesById.set(n.id, { id: n.id, name: n.name, type: n.type, children: [] });
        const existing = nodesById.get(n.id);
        // keep latest known name/type if available
        if (n.name) existing.name = n.name;
        if (n.type) existing.type = n.type;
        return existing;
      };

      // Ensure root exists
      const rootNode = ensureNode(payload.root);

      // Merge all paths into a single tree
      (payload.layers || []).forEach(path => {
        const { nodes = [], rels = [] } = path || {};
        // Ensure nodes exist in map
        nodes.forEach(ensureNode);
        // Link by rels order
        rels.forEach(rel => {
          const parent = nodesById.get(rel.from);
          const child = nodesById.get(rel.to);
          if (!parent || !child) return;
          // Avoid duplicate child edges
          const has = parent.children.some(c => c.id === child.id);
          if (!has) {
            const childRef = nodesById.get(child.id);
            // annotate stake from parent for label
            const annotated = { ...childRef, _stakeFromParent: rel.stake };
            // note: we keep reference semantics shallow; rendering uses fields
            parent.children.push(annotated);
          }
        });
      });

      return nodesById.get(payload.root.id) || rootNode;
    }

    async function loadLayers() {
      const rootId = document.getElementById('rootId').value.trim();
      const depth = Number(document.getElementById('depth').value || 2);
      if (!rootId) { alert('Please enter a root entity id'); return; }

      const treeEl = document.getElementById('layersTree');
      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Loading layers…';
      try {
        const res = await fetch(`/layers/${encodeURIComponent(rootId)}?depth=${depth}`);
        if (!res.ok) {
          const errText = await res.text();
          treeEl.textContent = `Failed to load layers (${res.status}): ${errText}`;
          statusEl.textContent = '';
          return;
        }
        const data = await res.json();
        const tree = buildTreeFromPaths(data);
        if (!tree) {
          treeEl.textContent = 'No layers found for this root.';
        } else {
          renderTree(treeEl, tree, data?.root?.id);
        }
      } catch (e) {
        treeEl.textContent = `Error: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 1500);
      }
    }

    async function loadMock() {
      document.getElementById('status').textContent = '';
      const res = await fetch('/mock-data');
      if (!res.ok) {
        document.getElementById('mockJson').textContent = 'Failed to load mock data';
        return;
      }
      const data = await res.json();
      document.getElementById('mockJson').textContent = JSON.stringify(data, null, 2);
    }

    async function populateMock() {
      document.getElementById('status').textContent = 'Populating...';
      const res = await fetch('/populate-mock', { method: 'POST' });
      const txt = await res.json().catch(()=>({message: res.statusText}));
      document.getElementById('status').textContent = JSON.stringify(txt);
      // After populating, try loading default root E1 automatically
      try {
        await loadLayers();
      } catch {}
      setTimeout(()=>document.getElementById('status').textContent='', 3000);
    }

    async function loadPenetration() {
      const rootId = document.getElementById('rootId').value.trim();
      const depth = Number(document.getElementById('depth').value || 3);
      if (!rootId) { alert('Please enter a root entity id'); return; }

      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Loading penetration…';
      try {
        const res = await fetch(`/penetration/${encodeURIComponent(rootId)}?depth=${depth}`);
        if (!res.ok) {
          const txt = await res.text();
          document.getElementById('penetrationChart').textContent = `Failed: ${res.status} ${txt}`;
          statusEl.textContent = '';
          return;
        }
        const data = await res.json();
        renderPenetrationChart(data);
      } catch (e) {
        document.getElementById('penetrationChart').textContent = `Error: ${e}`;
      } finally {
        setTimeout(()=>statusEl.textContent='', 1500);
      }
    }

    function renderPenetrationChart(data) {
      const items = (data && data.items) ? data.items.slice() : [];
      const root = data && data.root ? data.root : null;
      const chartEl = document.getElementById('penetrationChart');
      chartEl.innerHTML = '';
      if (!items.length) {
        chartEl.textContent = 'No penetration results.';
        return;
      }

      // Sort by penetration desc
      items.sort((a,b)=> (b.penetration||0) - (a.penetration||0));

      const margin = { top: 20, right: 30, bottom: 30, left: 200 };
      const width = 900 - margin.left - margin.right;
      const barH = 24;
      const height = items.length * barH + margin.top + margin.bottom;

      const svg = d3.select(chartEl).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height);

      const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

      const x = d3.scaleLinear()
        .domain([0, d3.max(items, d => d.penetration || 0) || 100])
        .range([0, width]);

      const y = d3.scaleBand()
        .domain(items.map(d => `${d.name || '(no name)'} [${d.id}]`))
        .range([0, items.length * barH])
        .padding(0.15);

      g.append('g')
        .attr('transform', `translate(0,${items.length * barH})`)
        .call(d3.axisBottom(x).ticks(6).tickFormat(d => `${d}%`));

      g.append('g')
        .call(d3.axisLeft(y));

      g.selectAll('rect.bar')
        .data(items)
        .enter()
        .append('rect')
        .attr('class', 'bar')
        .attr('x', 0)
        .attr('y', d => y(`${d.name || '(no name)'} [${d.id}]`))
        .attr('width', d => x(d.penetration || 0))
        .attr('height', y.bandwidth())
        .attr('fill', '#4e79a7');

      g.selectAll('text.value')
        .data(items)
        .enter()
        .append('text')
        .attr('class', 'value')
        .attr('x', d => x(d.penetration || 0) + 5)
        .attr('y', d => (y(`${d.name || '(no name)'} [${d.id}]`) || 0) + y.bandwidth()/2 + 4)
        .style('font-size', '12px')
        .text(d => `${(d.penetration || 0).toFixed(2)}%`);

      if (root) {
        d3.select(chartEl)
          .insert('div', ':first-child')
          .style('margin-bottom', '6px')
          .style('color', '#555')
          .text(`Root: ${root.name || ''} [${root.id}]${root.type ? ' · ' + root.type : ''}`);
      }
    }

    document.getElementById('refresh').addEventListener('click', loadMock);
    document.getElementById('populate').addEventListener('click', populateMock);
    document.getElementById('loadLayers').addEventListener('click', loadLayers);
    document.getElementById('loadPenetration').addEventListener('click', loadPenetration);
    loadMock();
  </script>
</body>
</html>
